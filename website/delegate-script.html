---
layout: default
---

<h2>Delegate Script</h2>

<p>The delegate script mechanism enables the use of custom Ruby methods as "hooks" to provide dynamic information back to the image server. A truly dynamic and customized image server can be created with minimal lines of code.</p>

<p>A sample delegate script, <span class="filename">delegates.rb.sample</span>, is included in the distribution. This should be copied to <span class="filename">delegates.rb</span> and referenced from the <code>delegate_script</code> configuration option, like:

<pre># Option 1: absolute pathname
delegate_script = /path/to/delegates.rb

# Option 2: filename only; will be expected to be located in the
# same folder as the config file, or the current working directory
delegate_script = delegates.rb</pre>

<p>The delegate script mechanism is optional and does not have to be used at all. In that case, the <code>delegate_script</code> option can be commented out or left blank.</p>

<h3>Rules</h3>

<p>While the arguments and return types of each method will vary, the script itself must contain a <code>Cantaloupe</code> module within which all delegate methods are contained.</p>

<p>Inside a method, anything goes&mdash;it will be interpreted by a JRuby interpreter built into Cantaloupe, so you can even use any (non-platform-native) gems that you have installed with <code>gem install</code>.</p>

<p>Because it will be called upon each image request, though, it should be written with efficiency in mind.</p>

<div class="alert alert-info">Scripts will be reloaded on each request, so they can be edited without restarting. However, be aware that code that has been loaded cannot be unloaded. For example, when a method is updated, it will overwrite the old version; but a constant that has already been loaded cannot be changed.</div>

<div class="alert alert-danger">Note: typically, neither method arguments nor return values are sanitized or validated. <strong>Be very careful to write defensive, injection-aware code.</strong></div>

<h3>Example</h3>

<p>Here is an example of a script used by <a href="resolvers.html#FilesystemResolver">FilesystemResolver</a> that performs a Solr query to return a pathname based on an identifier. The documentation in that section describes the contract that this method must abide by: its name, arguments, and return value.</p>

<pre>require 'cgi'
require 'net/http'

module Cantaloupe
  def self.get_pathname(identifier)
    uri = 'http://localhost:8983/solr/collection1/select?q=' +
        CGI.escape('id:"' + identifier + '"') +
        '&amp;fl=pathname_si&amp;wt=ruby'
    uri = URI.parse(uri)

    http = Net::HTTP.new(uri.host, uri.port)
    request = Net::HTTP::Get.new(uri.request_uri)
    response = http.request(request)
    return nil if response.code.to_i >= 400

    results = eval(response.body)['response']['docs']
    results.any? ? results.first['pathname_si'] : nil
  end
end</pre>
