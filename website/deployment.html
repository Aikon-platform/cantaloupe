---
layout: default
---

<h2>Deployment</h2>

<p>This page gathers some miscellaneous notes on production deployment. It is not intended to be comprehensive, and there is plenty of relevant information in other sections as well.</p>

<h3 id="Hardware">Hardware</h3>

<h4 id="HardwareCPU">CPU</h4>

<p>Response times benefit from multiple fast CPU cores. Even if a particular processor doesn't support multithreading, the operating system is at least likely to schedule different processing threads (from simultaneous requests) on different cores.</p>

<p>A 64-bit CPU is also important, in order to be able to address more than 4GB of RAM.</p>

<h4 id="HardwareMemory">Memory</h4>

<p>Consider the case of an image server that is asked to render tiles for an 8192&times;8192 pixel source image that, at 24 bits per pixel, totals 201 MB in
uncompressed size. Multiple clients are simultaneously requesting numerous downscaled tiles. For each request, a request handler needs to load this large image and operate on it independently.</p>

<p>Furthermore, some processors are inefficient in that they have to create new images internally at each intermediate step in the processing pipeline&mdash;cropping, scaling, rotating, etc.&mdash;each one consuming precious memory.</p>

<p>It's easy to see how RAM becomes a major consideration here, and why, for an image server, more is usually better.</p>

<p>With the processors that do their work in Java&mdash;as opposed to forking out to an external process&mdash; it is normal to see transient spikes of hundreds of megabytes of used memory on the Java heap in response to a single zooming-image-viewer action. The JVM will accommodate by dynamically increasing the heap size (the amount of RAM available to the application). From the operating system's perspective, the Java process is bloating up to immense size, but there is nothing wrong&mdash;most of this is actually unused heap space.</p>

<p>The smaller the available heap space, the larger the source images, and the larger the number of simultaneous requests, the greater the likelihood of OutOfMemoryErrors. Unlike an OS-native application, a Java application is only able to access as much memory as its container (the JVM) allows it to. In production, it is highly recommended to use the <code>-Xmx</code> flag to increase the maximum heap size to the largest amount possible&mdash;for example, <code>-Xmx8g</code> for 8GB.</p>

<h4 id="HardwareStorage">Storage</h4>

<p>Cantaloupe benefits from fast read performance&mdash;in terms of both latency and throughput&mdash;in the underlying storage system. Throughput becomes more important as source image size increases. <a href="resolvers.html#FilesystemResolver">Local filesystem storage</a> is usually fastest, and often by a long shot.</p>

<h3 id="Limiting">Limiting</h3>

<p>A <code>max_pixels</code> configuration option is available to limit the maximum returned size of processed images. This is a "safety net" to prevent clients from bogging down the server.</p>

<p>(This does not affect requests for full-sized unmodified images, which do not significantly load the server because they are streamed through with no processing.)</p>

<h3 id="Reverse-Proxying">Reverse-Proxying</h3>

<p>Cantaloupe can be set up to run behind a reverse-proxy web server like Apache or nginx. The proxy should be set up to pass-through encoded URI characters without decoding them. It should also be configured to send the following headers:</p>

<table class="table table-striped">
  <tr>
    <th>Header</th>
    <th>Description</th>
    <th>Required?</th>
  </tr>
  <tr>
    <td><code>X-Forwarded-Proto</code></td>
    <td>Protocol of the client request; either <code>HTTP</code> or <code>HTTPS</code>.  If missing, HTTP will be assumed.</td>
    <td>No</td>
  </tr>
  <tr>
    <td><code>X-Forwarded-Host</code></td>
    <td>FQDN of the client-facing reverse proxy.</td>
    <td>Yes</td>
  </tr>
  <tr>
    <td><code>X-Forwarded-Port</code></td>
    <td>TCP port of the client-facing reverse proxy. Will default to 80 if missing.</td>
    <td>No</td>
  </tr>
  <tr>
    <td><code>X-Forwarded-Path</code></td>
    <td>Path to use as a base path. Will default to none if missing.</td>
    <td>No</td>
  </tr>
</table>

<p>If it is not possible to configure your reverse proxy to send these headers, the <code>base_uri</code> configuration option can be used instead; set it to the URI of the client-facing reverse proxy including any base path.</p>

<h3 id="SSL/TLS">SSL/TLS</h3>

<p>SSL/TLS is an involved subject that will not be covered here in any depth. Suffice to say that Cantaloupe supports TLS connections over HTTPS, configurable via the <code>https.*</code> keys in the configuration file. The general process for getting it working is to add a signed certificate (<span class="filename">.crt</span>) file to either a Java KeyStore (JKS) or PKCS#12 key store, and then refer to the key store file with the <code>https.key_store_path</code> configuration option.</p>

<p>HTTPS can also be enabled on a <a href="#Reverse-Proxying">reverse proxy</a>, in which case Cantaloupe requires no special configuration.</p>
